# 영속성 컨텍스트

중요한 2가지
- 객체와 관계형 데이터베이스 매핑하기 : 객체랑 관계형데이터를 어떻게 이을거?
- 영속성 컨텍스트
    - 엔티티를 영구 저장하는 환경 
    - EntityManager.persist(entity) -> EntityManager는 요청마다 만들어짐 -> 엔티티를 영속화한다.
    
 - 엔티티 컨텍스트는 논리적인 개념
 - 눈에 안보임
 - 엔티티매니저를 통해 영속성 컨텍스트에 접근
 
 ## 엔티티의 생명주기
 - 비영속
 - 영속
 - 준영속
 - 삭제
 
 
 ## 영속성 컨텍스트 장점
 - 디비와 어플리케이션 사이에 있기때문에 버퍼링(모았다가 디비에 한방에 보내기), 캐싱이 가능
 - 1차 캐시 -> 큰 도움은 안됨 (고객이 요청이 와서 비즈니스가 끝나면 영속성 컨텍스트 사라짐, 애플리케이션에서 널리 공유 안하기때문에 장점 미미), 객체지향에 장점이있음(뒤에서 설명)
 - 동일성 보장 -> 101번 2번 조회 member1 == member2 -> true 하나의 트랜잭션안에 똑같이 조회한 객체는 동일성을 보장 (자바컬랙션에서 가져온것 처럼! -> 1차 캐시가 있기때문에 가능한일)
 - 트랜잭션을 지원하는 쓰기 지연 : 커밋이 되면 그때 쿼리가 플러쉬가 되면서 날라감
 - 변경감지 :flush 시점에 1차캐시에 있는 엔티티와 스냅샷을 비교해서 다르면 update하고 커밋
 - 지연로딩

### Flush
- 애플리케이션의 변경내용을 데이터베이스에 반영
- 커밋될때 flush가 일어남
- 쓰기지연소에 있던 쿼리가 디비에 반영됨
- 플러시가 발생하면?
    - 변경감지 일어남
    - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
    - 쓰기지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)
- 영속성 컨텍스트를 Flush 하는 방법
    - em.flush()
    - 트랜잭션 커밋
    - JPQL 쿼리 실행 
 - Flush 를 하면 1차 캐시 다 지워지나요..? NO..!   => 변경감지, 쓰기지연 저장소에 있는 SQL이 디비에 반영만 됨!
 - 트랜잭션과 매우 무지 관련 => 데이터 동기화는 항상 트랜잭션의 커밋시에 맞추면 되기 때문에 커밋될때 플러시가 발생되는 것
 
## 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)
- 영속성 컨텍스트가 제공하는 기능을 사용 못함
- 준영속 상태로 만드는 방법
    - em,detach(entity)
    - em.clear()
    - em.close()